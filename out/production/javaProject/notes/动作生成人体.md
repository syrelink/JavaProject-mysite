## 运动的表示

### 1.基于运动学（Kinematic-Based）

- **“基于运动学”** 的方法就是通过描述这些关节和骨骼如何移动，来定义整个人的动作，而不去关心驱动这些动作的力（比如肌肉收缩）。

- 所以，一段人体运动就可以被看作是**一连串的骨架姿势（a sequence of skeletal poses）**

### 2.位置 vs. 旋转

> 要记录一个骨架的姿势，主要有两种方法：

1. **3D关节位置 (3D joint positions)**
   - **是什么**：直接记录下每一个关节在三维空间中的坐标 `(x, y, z)`。比如，手腕在 `(10, 20, 5)`，手肘在 `(15, 25, 10)` 等等。
   - **缺点**：这种方法只记录了位置，但没有记录骨骼之间的连接关系。你可能会得到一个手腕和手肘位置正确，但臂长却不符合物理规律的“断裂”姿势。
2. **骨骼旋转 (Bone rotations)**
   - **是什么**：不记录绝对位置，而是记录每一根骨骼相对于其“父”骨骼的旋转角度。例如，描述“前臂”相对于“上臂”弯曲了多少度，“手”相对于“前臂”旋转了多少度。
   - **优点**：这种方法更受青睐，因为它**天生就包含了骨骼的拓扑结构 (inherently encode skeletal topology)**。也就是说，你不可能让手腕在不改变手臂姿态的情况下凭空移动，因为它的位置是由整个手臂的旋转链决定的。这更符合人体的物理结构。

### 3.旋转的“格式”

> 既然用旋转更好，那么用什么数学方式来表示“旋转”呢？这里提到了三种：

1. **欧拉角 (Euler angles)**：最直观的方式，比如绕X、Y、Z轴各旋转多少度。但它有“万向节死锁”等问题，在某些角度会让计算变得不稳定。
2. **四元数 (Quaternions)**：一种更复杂的数学工具，可以避免欧拉角的问题，在动画和游戏引擎中很常用。
3. **6D旋转表示 (6D rotation representation)**：这是近年来**最流行**的一种方法。它的主要优点是**连续性 (continuity)**。简单来说，一个微小的旋转，在6D表示下的数值变化也是微小的。这对于**深度学习模型 (deep learning models)** 至关重要，因为AI模型喜欢平滑、连续的数据，这样更容易学习到运动的规律，而不会被数值上的“跳变”所困扰。

### 4.参数化人体模型

> 前面的方法都只关注了骨架，但真实的人是有高矮胖瘦的，身体表面是会随着动作而变形的。参数化模型就是为了解决这个问题。

**代表模型**：**SMPL**、SMPL-X、GHUM。你可以把它们想象成一个“通用”的、高度可定制的3D人体模板。

**工作原理**：这些模型不仅使用描述动作的**姿态参数 (pose parameters, 也就是上面说的骨骼旋转)**，还引入了**体型参数 (shape parameters)**。

- **姿态参数**：控制这个3D模型的动作。
- **体型参数**：像游戏里“捏人”时拉动的滑块，可以控制模型的高矮、胖瘦、身体比例等。

**最终效果**：通过结合姿态和体型这两种参数，模型不仅能摆出各种动作，还能生成不同体型的、表面皮肤会随之自然变形的完整3D人体。这就实现了**“几何感知”的运动表示 (geometry-aware motion representation)**。

**重要性**：这种表示方法对于模拟**精细的交互 (fine-grained interactions)** 至关重要。例如，当手去抓一个杯子时，计算机不仅知道骨架在动，还能知道手指的皮肤是如何与杯子表面接触和变形的。



## 物体表示

> 为了让AI能够学习和创造出逼真的人与物体互动的场景（比如开门、拿杯子），我们必须先用计算机能理解的语言来精确地描述这个“物体”，包括它的形状、运动方式以及哪些部位是用来交互的。

### 1. 描述物体的静态“形状”

这里介绍了三种主流的表示物体几何外形的方法，可以想象成是给物体“拍照”或“扫描”的不同技术。

- **点云 (Point clouds)** ☁️
  - **是什么**：将物体表面表示为一大堆无序的3D坐标点 `(x, y, z)` 的集合。就像用激光扫描仪扫过一个物体，在它表面留下成千上万个小点。
  - **优点**：非常灵活，能轻松表示各种复杂或不规则的形状。
- **网格 (Meshes)** 🕸️
  - **是什么**：通过**顶点 (vertices)** 和连接它们的**边 (edges)** 来构成一个个小面片（通常是三角形），这些面片拼接在一起就形成了物体的表面。这是3D游戏和动画中最常见的模型格式。
  - **优点**：能提供非常高清的几何细节，对于精确模拟接触点（比如手指碰到杯子表面的哪一点）非常重要。
- **基点集 (Basis Point Sets - BPS)** 🧩
  - **是什么**：一种更抽象、更紧凑的编码方法。它不直接存储物体的所有几何细节，而是将物体的形状信息编码成一个**固定维度**的数学表示（一个向量）。
  - **优点**：在保持对形状变化的鲁棒性的同时，也便于神经网络高效处理。可以把它理解为物体形状的一种“指纹”或“摘要”，方便AI快速识别和比较。

### 2.描述“运动中”的物体

物体不仅有静态的形状，还会移动。这里根据物体的特性分为了两种。

- **对于刚体 (Rigid objects) 🧊**
  - **定义**：指那些在运动中自身形状不会发生变化的物体，比如一块砖、一个杯子、一本书。
  - **表示方法**：使用 **6自由度 (6 Degrees of Freedom - 6DoF)** 格式。这需要6个数字来完全描述它在空间中的状态：
    - t∈R3: **平移 (translation)**，也就是物体中心在三维空间中的 `(x, y, z)` 位置。
    - R∈SO(3): **旋转 (rotation)**，也就是物体自身的朝向，比如它是正着放、倒着放还是侧着放。
  - 公式 T1:N=[t,R]1:N 表示在一段总共有 N 帧的动画中，每一帧都需要记录下该物体的平移和旋转状态。
- **对于带关节的物体 (Articulated objects) 💻**
  - **定义**：指那些自身包含可以活动部件的物体，比如笔记本电脑（屏幕可以开合）、柜子（抽屉可以拉出）、剪刀（可以开合）。
  - **表示方法**：通常用一个基础的3D网格 O(Ω) 来表示物体的整体形状，并通过一个**位姿参数 Ω** 来描述它的状态。这个 Ω 通常是一个7维的向量，包含了：
    - ω∈R: **关节旋转 (articulation rotation)**，这是最关键的部分，描述了物体活动部件的状态。例如，笔记本电脑屏幕打开的角度。
    - t∈R3: **物体整体的平移**，即整个物体在空间中的位置。
    - R∈SO(3): **物体整体的旋转**，即整个物体的朝向。

### 3.增强表示，为了更好的交互

为了让AI更好地理解“如何”与物体交互，研究人员还使用了一些辅助技术。

- **以物体为中心的交互区域 (Object-centric interaction regions)** 👉
  - 在物体的3D模型上，手动或自动地标注出通常用来交互的区域。例如，在杯子模型上标出“杯柄”，在门上标出“门把手”。这等于告诉AI：“嘿，人通常会接触这些地方！”
- **规范化技术 (Canonicalization techniques)** 📏
  - 将物体在数学上“摆正”到一个标准的、统一的姿态和位置。例如，无论一把椅子在房间的哪个角落、以何种角度放置，在分析它之前，都先把它在坐标系中旋转到“正面朝前、竖直向上”的标准姿态。这样做可以大大简化AI的学习难度，让模型能专注于学习交互动作本身，而不是被物体千变万化的初始位置和朝向所干扰。

### 场景表示

> **1. 如何将真实或虚拟的场景（如一个房间、一条街道）数据化地“录入”计算机？** (场景获取)； **2. 用什么样的数据格式来组织这些场景信息，才能让AI高效地学习和处理？** (场景表示)。

**点云 (Point clouds) ☁️**

- **是什么**：这是最常用的一种格式，因为它既**轻量**又能保留详细的几何信息。每个点都包含了 `(x, y, z)` 空间坐标，还可以附加额外信息，如**表面法线**（该点的朝向）或**语义标签**（例如，这个点属于“墙壁”、那个点属于“地板”）。
- **处理它的AI模型**：需要特殊的网络结构，如 **PointNet** 或 **PointTransformer**。

**占据栅格 (Occupancy grids) 和 体素表示 (Voxel representations) 🧱**

- **是什么**：这种方法将整个三维空间切分成许多个规则的小立方体（称为“体素”，Voxel）。然后为每个小立方体标记一个**二元信息**：这个空间是被物体占据了（1），还是空的（0）？
- **类比**：你可以把它想象成一个3D版的“我的世界 (Minecraft)”，整个场景都是由小方块构成的。
- **优点**：非常便于进行**碰撞检测**（比如，人会不会撞到墙）和空间推理，因此在人与场景的互动任务中特别有用。
- **处理它的AI模型**：常用**3D卷积神经网络 (3D-CNNs)** 或 **视觉Transformer (ViTs)**。

**基点集 (Basis Point Sets - BPS) 🧩**

- **是什么**：和之前在物体表示中提到的一样，BPS通过测量场景中每个点到一组预先定义的“基准点”的距离，来为整个场景的几何形状提供一种结构化的紧凑编码。可以理解为场景几何的“指纹”。

## HSI交互

> 为了让计算机生成的虚拟人（角色）能够像真人一样，在复杂的3D环境中智能、自然、且符合物理和逻辑地活动与交互，研究者们主要从三个大的方面入手解决问题。
>
> 这三个核心支柱分别是：
>
> 1. **动作生成系统 (Motion Generation System)**：如何构建一个能“动起来”的AI模型？
> 2. **环境约束 (Environment Constraints)**：如何保证TA的动作符合物理规律（不穿墙、不浮空）？
> 3. **上下文交互理解 (Contextual Interaction Understanding)**：如何让TA的动作“有意义”（知道椅子是坐的，门是用来穿过的）？

### 1.动作生成系统 - “怎么动？”

这是最基础的问题：如何让虚拟人从静止状态变为一连串流畅的动作？文章总结了三种主流的技术路线：

1. **分层/分阶段流水线 (Hierarchical / Stage-wise Pipelines)** 🏭
   - **思想**：把一个复杂的长时序动作任务，拆解成几个更简单的、可控的子任务，像流水线一样一步步完成。
   - **类比**：就像规划一次旅行，你不会一步到位，而是先决定目的地（生成一个关键姿势或目标点），然后规划路线（生成路径），最后再填充细节（生成连接这些关键点的具体动作）。
   - **例子**：**COINS** 先确定骨盆位置，再补全全身姿势；**SAMP** 先预测交互目标，再规划无碰撞路径，最后生成全身动作。这种方法逻辑清晰，易于控制。
2. **自回归生成 (Auto-regressive Generation)** ➡️
   - **思想**：像写句子一样，一帧一帧地生成动作，下一帧的姿势是基于前面已经生成的姿势来预测的。
   - **优点**：理论上可以生成**无限长的动作序列**。
   - **例子**：**TRUMANS** 和 **LINGO** 使用了目前流行的**扩散模型 (Diffusion Model)**，通过自回归采样，不断地在已生成的动作后面“接龙”，创造出连贯的长时序动画。
3. **强化学习 (Reinforcement Learning - RL)** 🎮
   - **思想**：将动作生成看作一个“游戏”。AI代理（虚拟人）在一个环境中通过不断地“试错”来学习一套最优的“策略 (Policy)”，以完成某个目标（比如走到指定位置并坐下），并获得奖励。
   - **特点**：非常适合需要连续决策和与动态环境交互的任务。常常与**物理模拟器**结合，以获得最符合物理的动作。
   - **例子**：**UniHSI** 将语言指令转换为一系列的“接触点链 (Chain of Contacts)”，然后训练一个控制器去执行这些接触任务；**SIMS** 更是结合了**大语言模型 (LLM)** 进行高层规划（做什么），和底层的物理控制（怎么做）。

------



### 2.捕获环境约束 - “动得对不对？”

虚拟人动起来了，但不能“为所欲为”。他的动作必须符合物理世界的规则。文章总结了两种实现方式：

1. **后处理优化 / 物理模拟 (Post-optimization / Physics Simulation)** 🔧
   - **思想**：“先生成，后修正”。AI模型先生成一个初步的动作序列，然后通过一个优化步骤或物理引擎来检查和修正不合理的地方，比如修复穿模、增加地面接触、让脚不要在地面上滑动等。
   - **例子**：**PSI** 和 **COINS** 会在生成静态姿势后进行优化，以确保身体和场景有正确的接触；**CLoSD** 在扩散模型生成动作后，会接入一个物理模拟器来增强物理真实性。
2. **在生成过程中直接建模约束 (Modeling Constraints During Generation)** 🧠
   - **思想**：“从一开始就做对”。在AI模型生成动作的每一步，都将场景的几何信息作为输入，让模型自己学会遵守物理约束。
   - **具体技术**：
     - **特征表示**：如何把场景信息“喂”给AI？可以用**占据栅格 (Occupancy grids)** 告诉AI哪里有障碍物，用**距离场 (Distance fields)** 告诉AI身体离物体表面有多远。
     - **网络结构创新**：设计特殊的神经网络模块（如**交叉注意力机制 Cross-attention**），让模型能够同时“关注”自身的姿态和外部环境的结构，从而做出合理的动作。
   - **例子**：**MOB** 让AI在一个“规范化”的空间占据栅格中学习；**SceneDiffuser** 在扩散模型的采样过程中就加入了基于物理的目标（如接触和碰撞）。

### 3.理解空间交互上下文 - “动得有没有意义？”

这是最高级的要求。虚拟人不仅要动得符合物理，还要动得符合逻辑和常识。

- **思想**：让AI理解场景中各个物体是什么、它们之间有什么关系、以及它们“能用来做什么”（这在学术上称为**功能可见性 Affordance**）。
- **实现路径**：
  - **图模型 (Graph-based Modeling)**：将场景表示为一个关系图，节点是物体或人的身体部位，边是它们之间的空间或语义关系。这帮助AI理解“手”和“门把手”是需要交互的。
  - **语义理解**：利用语义标签（如“椅子”、“桌子”）来指导动作。**Purposer** 能够估计身体和场景的接触点，从而让虚拟人以符合语义的方式被“放置”在场景中（比如屁股接触椅子表面）。
  - **利用大模型 (LLMs & VLMs)**：这是当前最火的方向。利用**大语言模型 (LLM)** 或**视觉语言模型 (VLM)** 的强大常识推理能力，充当虚拟人的“大脑”。
    - **例子**：**GPT-Connect** 和 **UniHSI** 利用LLM将高级的文本命令（如“去给我倒杯水”）分解成一系列具体的、可执行的子任务（走向厨房 -> 找到水杯 -> 拿起水杯...）。**GenZI** 则利用VLM从2D图像中理解交互并提升到3D。



## HSI理解

1. **运动生成系统 (Motion Generation System):** 如何设计算法或模型架构来合成复杂的、依赖于场景的动作。
2. **环境约束 (Environment Constraints):** 如何确保生成的动作符合物理规律（例如，避免碰撞、正确接触物体表面）。
3. **情境交互理解 (Contextual Interaction Understanding):** 如何让系统理解场景的语义和交互上下文，以生成有意义的、符合情境的动作。

### ADM

- **核心目的**：学习**语言约束下的 Affordance Map 的分布**。即，给定 3D 场景 S 和语言描述 L，生成一个 Affordance Map $C$。
- **形式化**：ADM 是一个**条件扩散模型**。它通过迭代的去噪过程，从随机噪声 $C_t$ 逐步恢复到真实的 Affordance Map $C_0$，过程受 S 和 L 约束。
- **训练目标**：采用简单的 **均方误差 (MSE)** 目标 LMSE。它直接估计并预测**原始信号** C_0$ (即 Affordance Map)，而不是预测添加的噪声 ϵt。

