### **输入数据的结构与掩码调整流程**

#### **1. 输入数据的形式**
**原始运动序列**：
输入数据是一个时间长度为 \( T \)、包含 \( J \) 个关节的3D旋转角度序列，表示为二维时空网格 \( \{j^j_t\} \)，其中：

- **时间维度**：\( t = 1, 2, ..., T \)，表示运动序列的帧数。
- **空间维度**：\( j = 1, 2, ..., J \)，表示人体关节（如头部、手部、膝盖等）。
- **数据单元**：每个 \( j^j_t \) 是一个三维向量（3D旋转角度），表示关节 \( j \) 在时间 \( t \) 的姿态。

**数据结构示例**（假设 \( J=4 \)，\( T=5 \)）：
```
时间帧1: [关节1, 关节2, 关节3, 关节4]
时间帧2: [关节1, 关节2, 关节3, 关节4]
时间帧3: [关节1, 关节2, 关节3, 关节4]
时间帧4: [关节1, 关节2, 关节3, 关节4]
时间帧5: [关节1, 关节2, 关节3, 关节4]
```

---

#### **2. 数据编码与量化**
**编码过程**：
1. **2D卷积编码器**：将原始运动序列 $j^j_t$ 编码为2D向量图 \( V = $v^j_t$ \)，维度为 \( J \times T \times d \)（\( d \) 为向量维度）。
   - 每个向量 \( v^j_t \) 对应关节 \( j \) 在时间 \( t \) 的抽象特征表示。
   - 编码器包含两个卷积残差块，捕捉局部时空模式（如相邻帧的关节运动相关性）。

**量化过程**：
2. **Codebook替换**：通过预设的Codebook $C = \{c_i\}_{i=1}^C$，将每个向量 \( v^j_t \) 替换为最近的Codebook条目 \( \tilde{v}^j_t \)，生成离散的Token图 \( O = \{O^j_t\} \)。
   - Token索引 \( O^j_t = \arg\min_i \| c_i - v^j_t \|_2 \)。

**重建过程**：
3. **解码器**：将量化后的向量 \( \tilde{v}^j_t \) 解码为重建的关节角度 \( \tilde{j}^j_t \)，通过损失函数优化重建质量。

---

#### **3. 掩码调整流程**
掩码操作在**量化后的Token图** \( O \) 上进行，具体步骤如下：

##### **步骤1：时间维度掩码（整帧遮蔽）**
- **目标**：随机选择部分时间帧，遮蔽其所有关节的Token。
- **掩码比例**：由余弦调度函数动态控制：
  $$
  \gamma(\tau) = \cos\left(\frac{\pi\tau}{2}\right), \quad \tau \sim U(0,1)
  $$
  其中 \( \tau \) 是训练中均匀采样的比例系数，生成掩码比例 \( \gamma(\tau) \times T \times J \)。
- **示例**：若 \( \gamma(\tau)=0.3 \)，则掩码 \( 0.3 \times T \) 个时间帧。
- **结果**：
  ```
  帧1: [J1, J2, J3, J4]
  帧2: [M, M, M, M]      ← 时间掩码
  帧3: [J1, J2, J3, J4]
  帧4: [M, M, M, M]      ← 时间掩码
  帧5: [J1, J2, J3, J4]
  ```

##### **步骤2：空间维度掩码（单关节遮蔽）**
- **目标**：在未被时间掩码的帧中，随机遮蔽部分关节的Token。
- **掩码比例**：同一余弦调度函数，每帧掩码 \( \gamma(\tau) \times J \) 个关节。
- **示例**：在未掩码的帧1、3、5中，每帧掩码1个关节（\( \gamma(\tau)=0.25 \)）。
- **结果**：
  ```
  帧1: [M, J2, J3, J4]    ← 空间掩码（关节1）
  帧2: [M, M, M, M]
  帧3: [J1, M, J3, J4]    ← 空间掩码（关节2）
  帧4: [M, M, M, M]
  帧5: [J1, J2, M, J4]    ← 空间掩码（关节3）
  ```

##### **Remasking扰动机制**
- 对每个被选中的Token，按以下概率替换：
  - **80%**：替换为特殊Token `[MASK]`。
  - **10%**：替换为随机Codebook中的Token。
  - **10%**：保留原始Token。
- **目的**：防止模型过拟合固定模式，增强生成鲁棒性。

---

#### **4. 掩码后的输入构造**
- **Token图输入**：将掩码后的Token图展平为1D序列，并添加以下信息：
  1. **CLIP文本嵌入**：作为条件输入，与Token序列拼接。
  2. **二维位置编码**：对每个Token的位置 \( (j, t) \) 分别计算正弦编码，合并后得到时空位置嵌入。
- **示例**（部分掩码后的输入序列）：
  ```
  [CLS_TEXT, [M], J2, J3, J4, [M], [M], [M], [M], J1, [M], J3, J4, ...]
  ```

---

### **关键设计优势**
1. **结构化适配性**：
   - 时间掩码确保动作的全局连贯性（如保留完整站立帧），空间掩码细化局部合理性（如利用未掩码关节推断被遮蔽关节）。
2. **动态调度**：
   - 余弦掩码比例模拟人类学习过程（从易到难），初期掩码少，后期掩码多。
3. **抗过拟合机制**：
   - Remasking扰动防止模型依赖特定Token，提升泛化能力。

---

### **示意图示例**
若绘制成流程图，可展示以下步骤：
1. **原始数据** → **2D编码** → **量化Token图**。
2. **分层掩码**：
   - **时间掩码**（红色块覆盖整帧）→ **空间掩码**（黄色块覆盖单关节）。
3. **输入构造**：展平Token图 + 添加文本嵌入与位置编码。

通过这种调整，模型能够从部分观测的Token中，联合时空上下文与文本条件，生成高质量运动序列。